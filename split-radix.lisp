(deftype index ()
  `(unsigned-byte #. (min (1- (integer-length most-positive-fixnum))
                          (integer-length (1- array-dimension-limit)))))

(deftype half-index ()
  `(unsigned-byte #.(truncate (integer-length most-positive-fixnum) 2)))

(deftype size ()
  `(and (integer 1) index))

(deftype half-size ()
  `(and (integer 1) half-index))

(deftype complex-sample ()
  `(complex double-float))

(deftype complex-sample-array (&optional size)
  `(simple-array complex-sample (,size)))

(defmacro define-inline-function (name (&rest args) &body body)
  `(progn
     (declaim (inline ,name))
     (defun ,name (,@args)
       ,@body)
     (define-compiler-macro ,name (&rest arg-forms)
       `((lambda (,@',args) ,@',body)
         ,@arg-forms))))

(define-inline-function mul+i (x)
  (declare (type complex-sample x))
  #+ (and sbcl complex-float-vops)
  (sb-vm::swap-complex (conjugate x))
  #- (and sbcl complex-float-vops)
  (* x #c(0 1d0)))

(define-inline-function mul-i (x)
  (declare (type complex-sample x))
  #+ (and sbcl complex-float-vops)
  (conjugate (sb-vm::swap-complex x))
  #- (and sbcl complex-float-vops)
  (* x #c(0 -1d0)))

(define-inline-function mul+/-sqrt+i (x scale)
  (declare (type complex-sample x)
           (type double-float scale))
  #+ (and sbcl complex-float-vops)
  (let ((x (* x scale)))
    (+ x (sb-vm::swap-complex (conjugate x))))
  #- (and sbcl complex-float-vops)
  (* x (complex scale scale)))

(define-inline-function mul+/-sqrt-i (x scale)
  (declare (type complex-sample x)
           (type double-float scale))
  #+ (and sbcl complex-float-vops)
  (let ((x (* x scale)))
    (- x (sb-vm::swap-complex (conjugate x))))
  #- (and sbcl complex-float-vops)
  (* x (complex scale (- scale))))

(defun mul-root (x root &optional default)
  (setf root (mod root 1))
  (case root
    (0 x)
    (1/2
     `(- ,x))
    (1/4
     `(mul+i ,x))
    (3/4
     `(mul-i ,x))
    ((1/8 5/8)
     `(mul+/-sqrt+i
       ,x
       ,(case root
          (1/8 (/ (sqrt 2d0) 2d0))
          (5/8 (- (/ (sqrt 2d0) 2d0))))))
    ((3/8 7/8)
     `(mul+/-sqrt-i
       ,x
       ,(case root
          (3/8 (- (/ (sqrt 2d0) 2d0)))
          (7/8 (/ (sqrt 2d0) 2d0)))))
    (t
     (assert default)
     `(* ,x ,default))))

(defun bit-reverse (array)
  (let ((dst (copy-seq array))
        (width (integer-length (1- (length array)))))
    (flet ((rev (x)
             (let ((acc 0))
               (loop repeat width
                     for bit = (logand x 1)
                     do (setf x (ash x -1))
                        (setf acc (logior (ash acc 1) bit))
                     finally (return acc)))))
      (dotimes (i (length array) dst)
        (setf (aref dst (rev i)) (aref array i))))))

(defconstant +twiddle-offset+ -1)

(defun make-twiddle (n)
  (assert (= 1 (logcount n)))
  (let ((vec (make-array n :element-type 'complex-sample
                           :initial-element (complex 0d0 0d0))))
    (loop for size = 4 then (* 2 size)
          while (<= size n)
          do (let ((start (+ (truncate size 2) +twiddle-offset+))
                   (base  (/ (* 2 pi) size)))
               (dotimes (i (truncate size 4))
                 (let* ((theta (* -1 i base))
                        (t1 (cis theta))
                        (t2 (cis (* 3 theta))))
                   (setf (aref vec (+ start (* 2 i)))   t1
                         (aref vec (+ start 1 (* 2 i))) t2)))))
    vec))

(defun impulse (i n)
  (let ((vec (make-array n :element-type 'complex-sample
                           :initial-element (complex 0d0 0d0))))
    (setf (aref vec i) (complex 1d0 0d0))
    vec))

;; todo: unroll, fully or partially
(defun unrolled-for (count bindings body)
  `(progn
     ,@(loop
         for i below count
         collect
         `(symbol-macrolet ,(loop for (name start stride) in bindings
                                  collect (if (numberp stride)
                                              `(,name (+ ,start ,(* stride i)))
                                              `(,name (+ ,start (* ,stride ,i)))))
            ,@body))
     nil))

(defmacro for ((count &rest bindings) &body body)
  (let ((bindings (loop for binding in bindings
                        collect
                        (destructuring-bind (name &optional (start 0) (stride 1))
                            (if (consp binding)
                                binding
                                (list binding))
                          (list name start stride)))))
    (cond ((and (integerp count)
                (<= count 8)
                (not (find-if-not #'atom bindings :key #'second))
                (not (find-if-not #'constantp bindings :key #'third)))
           (unrolled-for count bindings body))
          ((and (integerp count)
                (zerop (mod count 4))
                (not (find-if-not #'constantp bindings :key #'third)))
           (let ((gensyms (mapcar (lambda (binding)
                                    (make-symbol (symbol-name (first binding))))
                                  bindings)))
             `(loop for ,(gensym "DUMMY") of-type index from ,(truncate count 4) above 0
                    ,@(loop for (name start stride) in bindings
                            for gensym in gensyms
                            append `(for ,gensym of-type index from ,start by ,(* stride 4)))
                    do (progn
                         ,@(loop
                             for i below 4
                             collect
                             `(symbol-macrolet
                                  ,(loop for (name start stride) in bindings
                                         for gensym in gensyms
                                         collect (if (numberp stride)
                                                     `(,name (+ ,gensym ,(* stride i)))
                                                     `(,name (+ ,gensym (* ,stride ,i)))))
                                ,@body))))))
          (t
           `(loop for ,(gensym "DUMMY") of-type index from ,count above 0
                  ,@(loop for (name start stride) in bindings
                          append `(for ,name of-type index from ,start by ,stride))
                  do (locally
                         ,@body))))))

(defun gen-base-difs ()
  (list `(dif/1 (start)
          (declare (ignore start))
          nil)
        `(dif/2 (start)
          (declare (type index start))
          (let ((s0 (aref vec start))
                (s1 (aref vec (1+ start))))
            (setf (aref vec start) (+ s0 s1)
                  (aref vec (1+ start)) (- s0 s1)))
          nil)
        `(dif/4 (start)
          (declare (type index start))
          (let* ((s0 (aref vec start))
                 (s2 (aref vec (+ start 2)))
                 (s0+s2 (+ s0 s2))
                 (s0-s2 (- s0 s2))
                 
                 (s1 (aref vec (+ start 1)))
                 (s3 (aref vec (+ start 3)))
                 (s1+s3 (+ s1 s3))
                 (s1-s3 (mul+i (- s1 s3))))
            (setf (aref vec start)       (+ s0+s2 s1+s3)
                  (aref vec (+ start 1)) (- s0+s2 s1+s3)
                  (aref vec (+ start 2)) (- s0-s2 s1-s3)
                  (aref vec (+ start 3)) (+ s0-s2 s1-s3)))
          nil)
        `(dif/8 (start)
          (declare (type index start))
          (let* ((s0 (aref vec start))
                 (s4 (aref vec (+ start 4)))
                 (s0+4 (+ s0 s4))
                 (s0-4 (- s0 s4))
                 
                 (s1 (aref vec (+ start 1)))
                 (s5 (aref vec (+ start 5)))
                 (s1+5 (+ s1 s5))
                 (s1-5 (- s1 s5))
                 
                 (s2 (aref vec (+ start 2)))
                 (s6 (aref vec (+ start 6)))
                 (s2+6 (+ s2 s6))
                 (s2-6 (- s2 s6))
                 
                 (s3 (aref vec (+ start 3)))
                 (s7 (aref vec (+ start 7)))
                 (s3+7 (+ s3 s7))
                 (s3-7 (- s3 s7)))
            (let ((a (+ s0+4 s2+6))
                  (b (+ s1+5 s3+7)))
              (setf (aref vec start)       (+ a b)
                    (aref vec (+ start 1)) (- a b)))
            (let ((a (+ s0-4 ,(mul-root 's2-6 -2/8)))
                  (b ,(mul-root `(+ s1-5 ,(mul-root 's3-7 -2/8))
                                -1/8)))
              (setf (aref vec (+ start 4)) (+ a b)
                    (aref vec (+ start 5)) (- a b)))
            (let ((a (- s0+4 s2+6))
                  (b ,(mul-root '(- s1+5 s3+7)
                                -2/8)))
              (setf (aref vec (+ start 2)) (+ a b)
                    (aref vec (+ start 3)) (- a b)))
            (let ((a (+ s0-4 ,(mul-root 's2-6 -6/8)))
                  (b ,(mul-root `(+ ,(mul-root 's1-5 -2/8)
                                    s3-7)
                                -1/8)))
              (setf (aref vec (+ start 6)) (+ a b)
                    (aref vec (+ start 7)) (- a b)))
            nil))))

(defun gen-dif (n)
  (let ((defs '())
        (base-defs (gen-base-difs)))
    (labels ((name (n)
               (intern (format nil "~A/~A" 'dif n)))
             (gen (n)
               (cond
                 ((= n 16)
                  (push
                   `(dif/16 (start)
                     (declare (type index start))
                     (let* ((start2 (+ start  8))
                            (start3 (+ start2 4)))
                       (for (8 (i start)
                               (j start2))
                         (let ((x (aref vec i))
                               (y (aref vec j)))
                           (setf (aref vec i) (+ x y)
                                 (aref vec j) (- x y))))
                       (dif/8 start)
                       ,@(loop
                           for i below 4
                           collect
                           `(let ((x (aref vec (+ start2 ,i)))
                                  (y (mul-i (aref vec (+ start3 ,i)))))
                              (setf (aref vec (+ start2 ,i))
                                    ,(mul-root `(+ x y) (* 1/16 i)
                                               `(aref twiddle ,(+ 8 +twiddle-offset+
                                                                  (* 2 i))))
                                    (aref vec (+ start3 ,i))
                                    ,(mul-root `(- x y) (* 3/16 i)
                                               `(aref twiddle ,(+ 8 +twiddle-offset+
                                                                  1
                                                                  (* 2 i)))))))
                       (dif/4 start2)
                       (dif/4 start3)))
                   defs))
                 ((> n 8)
                  (gen (truncate n 2))
                  (let* ((n/2 (truncate n 2))
                         (n/4 (truncate n 4))
                         (name/2 (name n/2))
                         (name/4 (name n/4))
                         (body
                           `(,(name n) (start)
                             (declare (type index start))
                              (let* ((start2 (+ start  ,n/2))
                                     (start3 (+ start2 ,n/4)))
                                (for (,n/2 (i start)
                                           (j start2))
                                  (let ((x (aref vec i))
                                        (y (aref vec j)))
                                    (setf (aref vec i) (+ x y)
                                          (aref vec j) (- x y))))
                                (,name/2 start)
                                (for (,n/4 (i start2)
                                           (j start3)
                                           (k ,(+ n/2 +twiddle-offset+) 2))
                                  (let ((x (aref vec i))
                                        (y (mul-i (aref vec j)))
                                        (t1 (aref twiddle k))
                                        (t2 (aref twiddle (1+ k))))
                                    (setf (aref vec i) (* t1 (+ x y))
                                          (aref vec j) (* t2 (- x y)))))
                                (,name/4 start2)
                                (,name/4 start3)))))
                    (push body defs))))))
      (gen n)
      `(labels (,@base-defs ,@(nreverse defs))
         (declare (ignorable ,@(mapcar (lambda (x) `#',(car x)) base-defs))
                  (inline ,@(mapcar #'car base-defs)
                          ,(name n)))
         (,(name n) start)))))

(defun %dif (vec start n twiddle)
  (declare (type complex-sample-array vec twiddle)
           (type index start)
           (type size n))
  (labels ((rec (start n)
             (declare (type index start)
                      (type size n)
                      (optimize speed (safety 0)))
             (cond ((>= n 4)
                    (let* ((n/2    (truncate n 2))
                           (start2 (+ start n/2))
                           (n/4    (truncate n/2 2))
                           (start3 (+ start2 n/4)))
                      (for (n/2 (i start)
                                (j start2))
                        (let ((x (aref vec i))
                              (y (aref vec j)))
                          (setf (aref vec i) (+ x y)
                                (aref vec j) (- x y))))
                      (rec start n/2)
                      (for (n/4 (i start2)
                                (j start3)
                                (k (+ n/2 +twiddle-offset+) 2))
                        (let ((x (aref vec i))
                              (y (mul-i (aref vec j)))
                              (t1 (aref twiddle k))
                              (t2 (aref twiddle (1+ k))))
                          (setf (aref vec i) (* t1 (+ x y))
                                (aref vec j) (* t2 (- x y)))))
                      (rec start2 n/4)
                      (rec start3 n/4)))
                   ((= n 2)
                    (let ((s0 (aref vec start))
                          (s1 (aref vec (1+ start))))
                      (setf (aref vec start) (+ s0 s1)
                            (aref vec (1+ start)) (- s0 s1)))
                    nil))))
    (rec start n)
    vec))

(defun %dit (vec start n twiddle)
  (declare (type complex-sample-array vec twiddle)
           (type index start)
           (type size n))
  (labels ((rec (start n)
             (declare (type index start)
                      (type size n)
                      (optimize speed (safety 0)))
             (cond ((>= n 4)
                    (let* ((n/2    (truncate n 2))
                           (start2 (+ start n/2))
                           (n/4    (truncate n/2 2))
                           (start3 (+ start2 n/4)))
                      (rec start3 n/4)
                      (rec start2 n/4)
                      (for (n/4 (i start2)
                                (j start3)
                                (k (+ n/2 +twiddle-offset+) 2))
                        (let* ((t1 (conjugate (aref twiddle k)))
                               (t2 (conjugate (aref twiddle (1+ k))))
                               (x  (* (aref vec i) t1))
                               (y  (* (aref vec j) t2)))
                          (setf (aref vec i) (+ x y)
                                (aref vec j) (mul+i (- x y)))))
                      (rec start n/2)
                      (for (n/2 (i start)
                                (j start2))
                        (let ((x (aref vec i))
                              (y (aref vec j)))
                          (setf (aref vec i) (+ x y)
                                (aref vec j) (- x y))))))
                   ((= n 2)
                    (let ((s0 (aref vec start))
                          (s1 (aref vec (1+ start))))
                      (setf (aref vec start)      (+ s0 s1)
                            (aref vec (1+ start)) (- s0 s1)))
                    nil))))
    (rec start n)
    vec))
